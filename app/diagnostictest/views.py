# Create your views here.

from drf_spectacular.utils import (
    extend_schema_view,
    extend_schema,
    OpenApiParameter,
    OpenApiTypes,
)

from rest_framework import (
    viewsets,
)
from rest_framework.authentication import TokenAuthentication
from rest_framework.permissions import IsAuthenticated

from core.models import (
    DiagnosticTest,
    Tag,
)
from diagnostictest import serializers


# The extend schema view allows us to extend the auto generated schema that is generated by drf spectacular.
# Then we defining lists and what we are saying here is we want to extend the schema for the list endpoint.
# Then we are setting parameters that can be passed in to the requests that are made to the list API
# we're using open API parameter, which is a parameter class as provided by drf spectacular
# it allows us to specify the details of the parameters that can be accepted by the API request
# So here we're specifying the name tags as the name of the parameter that you're going to
# need to pass in in order to filter them.
# We define the type as a string as we want to pass a comma separated set of tag ids
# We later convert them to a list of intergers as we will see below.
@extend_schema_view(
    list=extend_schema(
        parameters=[
            OpenApiParameter(
                'tags',
                OpenApiTypes.STR,
                description='Comma separated list of tag IDs to filter',
            ),
        ]
    )
)
class DiagnosticTestViewSet(viewsets.ModelViewSet):
    """View for manage DiagnosticTest APIs."""
    # First we tell it what serializer to use
    serializer_class = serializers.DiagnosticTestDetailSerializer
    # We define the queryset to return all the objects
    queryset = DiagnosticTest.objects.all()
    # We define that authentication is needed to access the viewset and that tokenauth
    authentication_classes = [TokenAuthentication]
    # We define that the user must be authenticated to be able to access this viewset.
    permission_classes = [IsAuthenticated]

# This is for filtering by tags. We will take in the tag ids as a comma separated strings.
# This method converts them to a list of integers
    def _params_to_ints(self, qs):
        """Convert a list of strings to integers."""
        return [int(str_id) for str_id in qs.split(',')]

# By default the queryset will consist of all the diagnostictest objects
# as we have defined at the beginning of this class.
# But we want to be able to filter the objects based on some parameters.
# So thats why we override this get_queryset method.
# We first retrieve the tags from the query parameters and store it in a tags variable
# Then we get a reference to the self.queryset. at this point the queryset contains all the diagnostictest objects.
# We do this so that we can apply filters to the queryset and return the resulting filtered output.
# Then if there are any tags, we first convert the comma separated tag ids to a list of integers
# Then we filter the queryset based on diagnostic tests that have all the tags that are passed in.
# This is the filtering syntax Django allows us to use for related fields on a database table.
# Once this filtering is done, we apply the filter to only return the diagnostictests for the authenticated user
# orderd by the diagnostictest id and a distinct set so that we dont have any duplicate values in the response.
    def get_queryset(self):
        """Retrieve diagnostic tests filtered by tags and for the authenticated user."""
        tags = self.request.query_params.get('tags')
        queryset = self.queryset
        if tags:
            tag_ids = self._params_to_ints(tags)
            # here we loop through the tags and filter the queryset
            for t in tag_ids:
                queryset = queryset.filter(tags__id=t)
            # by the end of this for loop only diagnostictest objects that contain all the tags will be returned.

        return queryset.filter(
            user=self.request.user
        ).order_by('-id').distinct()

# We want to be able to use a specific serializer based on the endpoint that is called.
# The way that we do that is we override the method called get serialize class method.
# Above we set the serializer_class to use the DetailSerializer by default for all diagnostic test actions.
# But if action is listing, we want to use the DiagnosticTestSerializer. For all other actions it will
# return the serializer_class which we set to DiagnosticTestDetailSerializer
    def get_serializer_class(self):
        """Return the serializer class for request."""
        if self.action == 'list':
            return serializers.DiagnosticTestSerializer
        return self.serializer_class

# This method ensures we save the correct user to the diagnostictests.
# So this perform create method is the way that we override the behavior for when Django Restaurant work
# saves a model in a viewset
# So when we create a new diagnostictest through the create feature of the view, so we're going to call this
# method as part of that object creation.
# So we're going to call it accepts one parameter which is the serialization, and this should be the
# validated sterilizer.
# So we can expect the serialized data to already be validated by the view set before this method is called,
# and then this method is called, and we can just simply do serialize autosave and we can set user equal
# self to request or user, which will set the user value to the current authenticated user when we save
# the object.
    def perform_create(self, serializer):
        """Create a new Diagnostic Test."""
        serializer.save(user=self.request.user)


# The url methods that show up in the doc or that are allowed is based on the methods mentioned in Mixin
class TagViewSet(viewsets.ModelViewSet):
    """Manage tags in the database."""
    serializer_class = serializers.TagSerializer
    queryset = Tag.objects.all()
    authentication_classes = [TokenAuthentication]
    permission_classes = [IsAuthenticated]

# This method is used when we want list all the tags and ensures
# that only the tags created by the current user are displayed
    def get_queryset(self):
        """Filter queryset to authenticated user."""
        return self.queryset.filter(user=self.request.user).order_by('-name')

# This method is called during the tag creation and ensures that the current user is also saved along with the tag.
    def perform_create(self, serializer):
        """Create a new Tag."""
        serializer.save(user=self.request.user)
