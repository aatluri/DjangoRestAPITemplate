# version of the docker compose syntax that we are using .
# This is just in case Docker compose, release new versions of the syntax.
# it's a version mechanism to make sure that the syntax we use here matches the specific version.
# if they were to release new versions, it wouldn't break out configuration.
# When you use this command, you might get a warning version is obsolete. Technically you dont need to specify the version as  it wonâ€™t be used.
# The docker compose v2 (=the cli plugin) will always use the latest version of the compose file schema.
# version: "3.9" 

# This is the main block inside the Docker compose file. It consists of one more services needed by our application
# app is the name of our service
# We have build context and the current directory. What this does is it says we want to build the Docker file inside our current directory. 
# The . means current directory
# We then set an argument DEV=TRUE. This will be used in the Docker File during build.
# Then we have the port mappings. So this maps port 8000 on our local machine to port 8000 inside our Docker container.
# This is how we can access the network when we want to connect to our server.
# Next we have volumes, volumes odd way of mapping directories from our system into the Docker container.
# So we're mapping the app directory that we created in the project to Ford's hash app inside our container.
# The reason we add this is because we want the updates that we make to our code in our local project to be reflected in the running container in real time.
# So we don't want to have to rebuild the container. 
# Every time we change a line of code, we want to automatically sync the code in our project to the cloud running in the container.
# Finally we have the command that is used to run the service.
# We can override this command when we run Docker compose run.
# However, by default, if we don't specify a command, it's going to use the command we define inside our Docker compose file.
services:
  app:
    build:
      context: .
      args:
        - DEV=true
    ports:
      - "8000:8000"
    volumes:
      - ./app:/app
    command: >
      sh -c "python manage.py runserver 0.0.0.0:8000"


# Run "docker-compose build" to build the image. So it effectively does the same as Docker build.
# However it does it via the Docker file, so it builds and tags the images appropriately for running our Docker compose configuration.